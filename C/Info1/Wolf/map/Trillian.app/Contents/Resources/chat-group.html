<html> 
	<head> 
		<title>Chat Style: Default</title> 
		<link rel="stylesheet" type="text/css" href="Default-group.css" id="ss" /> 
		<script type="text/javascript" language="JavaScript1.4"><!--
			var lastType = 'emptiness';
			var counter = 0;
			var oldIncomingAvatarParent = 0;
			var oldOutgoingAvatarParent = 0;
			var incomingAvatarEnclosure = 0;
			var outgoingAvatarEnclosure = 0;
			var recordedMessageBuffer = [];
			var recordedMessageLock = false;

			// Resize code
                        var resizeMode=0; function Resize() { if (resizeMode) { if ((document.body.scrollTop+window.innerHeight)*1.1 + 100 > document.body.scrollHeight) document.body.scrollTop = document.body.scrollHeight; } else { document.body.scrollTop = document.body.scrollHeight; } } window.addEventListener("resize", Resize, false); setTimeout(function(){ resizeMode=1 }, 10000);

			// This function allows a chat style to set the typing indicators in a
			// style-specific unique way.  They will be set to 'true' if the typing
			// indicator is presently on, and 'false' if not.
			//
			// Parameters:
			//		type		'incoming' or 'outgoing'.
			//		active		'true' or 'false'.
			//		avatar		base64 of the appropriate avatar.
			//
			function SetTyping( type, active, avatar ) 
			{
					
			}
			// RecordMessage records a message in auto-history buffer so that we can display
			// them at a future time all at once, sorted.
			//
			// Parameters:
			//		type			'info', 'action', or 'normal'
			//		incoming		BOOL
			//		avatar			URL of user's avatar
			//		displayname		displayname of user
			//		timestamp		timestamp in UTC format
			//		text			actual message, in HTML format
			function RecordMessage( type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid ) {
				console.log("RecordMessage " + " type=" + type + " incoming=" + incoming + " displayname=" + displayname + " timestamp=" + timestamp + " text(%-12s)=" + String(text).substr(0,12) +  " text.length=" + text.length + " sorted=" + sorted + " historical=" + historical + " guid=" + guid);
				recordedMessageBuffer.push({
					i: -1,
					mode: "message",
					historical: historical,
					guid: (guid==null||typeof(guid)=='undefined'?false:guid),
					type: type,
					incoming: incoming,
					avatar: avatar,
					displayname: displayname,
					timestamp: timestamp,
					text: text,
					sorted: true,
					dynamic: null
				});
			}
			// PlayMessages plays back the auto-history buffer all at once.  sorts first.
			//
			// Parameters:
			//		None
			function PlayMessages() {
				if (recordedMessageLock) 
					return setTimeout(PlayMessages, 100); 
				recordedMessageLock=true;
				var chat = document.getElementById('chat');
				var incoming_avatar = document.getElementById("incoming_avatar");
				var outgoing_avatar = document.getElementById("outgoing_avatar");
				var elements = document.getElementsByTagName("div");
				var noDelay = recordedMessageBuffer.length==1;
				if (elements.length) 
				{
					if (recordedMessageBuffer.length==1 && !recordedMessageBuffer[0].guid)
					{
						if (recordedMessageBuffer[0].timestamp > elements[elements.length-1].getAttribute('timestamp')) 
						{
							// This message is newer than the last message on the screen, so print then exit
							
							with (recordedMessageBuffer.shift()) 
							{
								switch (mode)
								{
									case "timestamp":
										PrintTimestamp(timestamp, dynamic, historical, guid);
										break;
									case "message":
										PrintMessage(type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid);
										if (!incoming || document.body.scrollTop + window.innerHeight + 100 > document.body.scrollHeight) 
											document.body.scrollTop = document.body.scrollHeight;
										break;
								}
							}
							if (document.getElementById("outgoing_avatar")) 
								document.getElementById("outgoing_avatar").setAttribute("src", document.getElementById("outgoing_avatar").getAttribute("rel"));
							if (document.getElementById("incoming_avatar")) 
								document.getElementById("incoming_avatar").setAttribute("src", document.getElementById("incoming_avatar").getAttribute("rel"));
							recordedMessageLock=false;
							return;					
						}
					}
					// scan for guids that we're replacing
					var ignore_these_guids = [];
					for (var g=0;g<recordedMessageBuffer.length;g++)
					{
						if (recordedMessageBuffer[g].guid)
						{
							ignore_these_guids.push(recordedMessageBuffer[g].guid);
						}
					}
					for(var i=0;i<elements.length;i++)
				  	{
						var guid = elements[i].getAttribute('guid');
						var ignoring = 0;
						if (guid && ignore_these_guids.length)
						{
							// scan to make sure we're not replacing this
						
							if (ignore_these_guids.indexOf(guid)>-1) 
							{
								continue;
							}
						}
						if (ignoring) 
							continue;
						if (elements[i].getAttribute('class') == "action" || elements[i].getAttribute('class') == "info" )
						{

							recordedMessageBuffer.push({
								mode: "message",
								order: i,
								historical: (elements[i].childNodes[0].getAttribute("class").match("historical")?true:false),
								guid: elements[i].getAttribute('guid'),
								type: elements[i].getAttribute('class'),
								incoming: (elements[i].parentElement.getAttribute("class").match("incoming")?"true":null),
								avatar: null,
								displayname: null,
								timestamp: elements[i].getAttribute("timestamp"),
								text: elements[i].childNodes[0].innerHTML,
								sorted: true

								});
						}
						else if(elements[i].getAttribute('timestamp') > 0) 
						{
							recordedMessageBuffer.push({
								mode: "message",
								order: i,
								historical: (elements[i].childNodes[0].getAttribute("class").match("historical")?true:false),
								guid: elements[i].childNodes[0].getAttribute("guid"),
								type: "normal",
								incoming: (elements[i].parentElement.getAttribute("class").match("incoming")?"true":null),
								avatar: (elements[i].parentElement.getAttribute("class").match("incoming")?(incoming_avatar?incoming_avatar.getAttribute("src"):""):(outgoing_avatar?outgoing_avatar.getAttribute("src"):"")),
								displayname: null,
								timestamp: elements[i].getAttribute("timestamp"),
								text: elements[i].childNodes[0].innerHTML,
								sorted: true

							});
						}

					}
				}
				var elements = document.getElementsByTagName("span");
				if (elements) 
				{
					for(var i=0;i<elements.length;i++)
				  	{
						if(elements[i].getAttribute('timestamp') > 0) 
						{
							if (elements[i].parentElement.getAttribute("class").match("timestamp"))
							{
								recordedMessageBuffer.push({
									mode: "timestamp",
									order: i,
									historical: (elements[i].parentElement.getAttribute("class").match("historical")?true:false),
									guid: elements[i].getAttribute("guid"),
									timestamp: elements[i].getAttribute("timestamp"),
									dynamic: (elements[i].parentElement.getAttribute("class").match("dynamic")?"true":"")
								});

							}
						}
					}
				}
				recordedMessageBuffer.sort(function(a,b) 
				{
					if (a.timestamp < b.timestamp) 
						return -1;
					if (a.timestamp > b.timestamp) 
						return 1;
					if (a.mode == "timestamp" && b.mode == "message") 
						return -1;
					if (a.mode == "message" && b.mode == "timestamp") 
						return 1;
					if (a.order < b.order) 
						return -1;
					if (a.order > b.order) 
						return 1;
					return 0;
				});
				document.getElementById("chat").innerHTML = "";
				lastType = 'emptiness';
				counter = 0;
				chat.style.display = "none";
				while (recordedMessageBuffer.length) 
				{
					with (recordedMessageBuffer.shift()) 
					{
						switch (mode)
						{
							case "timestamp":
								PrintTimestamp(timestamp, dynamic, historical, guid);
								break;
							case "message":
								PrintMessage(type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid);
								break;
						}
					}
				}
				if (document.getElementById("outgoing_avatar")) 
					document.getElementById("outgoing_avatar").setAttribute("src", document.getElementById("outgoing_avatar").getAttribute("rel"));
				if (document.getElementById("incoming_avatar")) 
					document.getElementById("incoming_avatar").setAttribute("src", document.getElementById("incoming_avatar").getAttribute("rel"));
				if (noDelay)
				{
					document.getElementById("chat").style.display = "block"; 
					document.body.scrollTop = document.body.scrollHeight;
				}
				else
					setTimeout(function(){ document.getElementById("chat").style.display = "block"; document.body.scrollTop = document.body.scrollHeight; }, 100);
				recordedMessageLock=false;
 			}
			function AddMessages( a_msgArray )
			{
				for ( l_msg in a_msgArray )
				{
					with (a_msgArray[l_msg])
					{
						RecordMessage( type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid );
					}
				}
				PlayMessages();
			}
			function AddMessage( type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid )
			{
//				RecordMessage( type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid );
//				PlayMessages();
				PrintMessage( type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid );
			}
			// PrintMessage is the main guts of our chat view.  This takes several
			// parameters, and can add them to the HTML view however the page sees fit.
			// 
			// Parameters:
			//		type			'info', 'action', or 'normal'
			//		incoming		BOOL
			//		avatar			URL of user's avatar
			//		displayname		displayname of user
			//		timestamp		timestamp in UTC format
			//		text			actual message, in HTML format
			//		sorted
			//		historical		different set of colors for auto-history items
			//		guid			unique identifier
			//
			function PrintMessage( type, incoming, avatar, displayname, timestamp, text, sorted, historical, guid ) {
					var chat = document.getElementById('chat');
					
					var direction = 'unknown';
					if (incoming == 'true') 
					{
						direction = 'incoming';
					}
					else {
						direction = 'outgoing';
					}
					
					var tr = document.createElement('tr');
					var td1 = document.createElement('td');
					tr.appendChild(td1);
					td1.setAttribute('width','60');
					td1.setAttribute('align','right');
					td1.setAttribute('valign','top');
					var text1 = document.createElement('span');
					text1.setAttribute('class','text timestamp');
					text1.innerHTML = '[XX:YY]'; // TODO: Proper timestamping
					td1.appendChild(text1);
					var td2 = document.createElement('td');
					td2.setAttribute('width','60');
					td2.setAttribute('align','right');
					td2.setAttribute('valign','top');
					var text2 = document.createElement('span');
					text2.setAttribute('class','text name_' + direction);
					text2.innerHTML = displayname;
					td2.appendChild(text2);
					tr.appendChild(td2);
					var td3 = document.createElement('td');
					td3.setAttribute('valign','top');
					td3.setAttribute('align','left');
					var text3 = document.createElement('span');
					text3.setAttribute('class','text');
					text3.innerHTML = text;
					td3.appendChild(text3);
					tr.appendChild(td3);
					chat.appendChild(tr);
			}
			
			// RecordTimestamp records a timestamp in auto-history buffer so that we can display
			// them at a future time all at once, sorted.
			//
			// Parameters:
			//		timestamp		timestamp in UTC format.
			//		dynamic			is the timestamp dynamic?
			//		historical		
			//		guid			unique identifier
			//
			function RecordTimestamp( timestamp, isDynamic, historical, guid )
			{
				//console.log("RecordTimestamp " + timestamp + " isDynamic=" + isDynamic + " historical=" + historical + " guid=" + guid);
				recordedMessageBuffer.push(
				{
					mode: "timestamp",
					historical: historical,
					guid: (guid==null||typeof(guid)=='undefined'?false:guid),
					timestamp: timestamp,
					dynamic: isDynamic,
				});
			}
			// setAvatar immediately sets the avatar.
			function setAvatar( incoming, avatar )
			{
			}
			// AddTimestamp is for new messages
			function AddTimestamp( timestamp, isDynamic, historical, guid )
			{
				RecordTimestamp( timestamp, isDynamic, historical, guid );
				PlayMessages();
			}
		
			// PrintTimestamp handles adding a simple relative timestamp to the
			// chat view.  This is important for the timestamps to be able to
			// change dynamically.
			// 
			// In addition, Trillian can update these timestamps /for/ the chat
			// view.  Any div classed as 'dynamic' will be checked for dynamic
			// content once a minute in the actual hard-coded webview.  If the
			// div contains a span classed with 'timestamp_relative' and an 
			// attribute named 'timestamp' containing a UTC timestamp, then the
			// text content of that span will be updated to contain a relative
			// timestamp, brought current once every minute.
			//
			// Parameters:
			//		timestamp		timestamp in UTC format.
			//		dynamic			is the timestamp dynamic?
			//
			function PrintTimestamp( timestamp, isDynamic, historical, guid ) {
 
			}
			if (!Array.indexOf)
			{
			  Array.indexOf = [].indexOf ?
			      function (arr, obj, from) { return arr.indexOf(obj, from); }:
			      function (arr, obj, from) { // (for IE6)
			        var l = arr.length,
			            i = from ? parseInt( (1*from) + (from<0 ? l:0), 10) : 0;
			        i = i<0 ? 0 : i;
			        for (; i<l; i++) {
			          if (i in arr  &&  arr[i] === obj) { return i; }
			        }
			        return -1;
			      };
			}


		// --></script> 
	</head> 
	<body> 
		<table width=100% id='chat'> 
		</table> 
	</body> 
</html>

